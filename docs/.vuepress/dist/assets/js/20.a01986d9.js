(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{255:function(t,s,a){"use strict";a.r(s);var n=a(0),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"对《你不知道的js》的记录-二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对《你不知道的js》的记录-二"}},[t._v("#")]),t._v(" 对《你不知道的JS》的记录 二")]),t._v(" "),a("p",[t._v("this关键字是 JavaScript 中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。接下来会先讲一下This，然后再涉及对象和类的相关知识。")]),t._v(" "),a("h2",{attrs:{id:"关于this的两个误解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于this的两个误解"}},[t._v("#")]),t._v(" 关于This的两个误解")]),t._v(" "),a("h3",{attrs:{id:"误解一-：-this-指向自身"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#误解一-：-this-指向自身"}},[t._v("#")]),t._v(" 误解一 ： this 指向自身")]),t._v(" "),a("p",[t._v("人们很容易把 this 理解成指向引用函数自身，这个推断从英语角度来讲是说得通的。")]),t._v(" "),a("p",[t._v("为什么要在函数内部调用自身呢？常见的原因的递归（自己调用自己）")]),t._v(" "),a("p",[t._v("我们可以通过以下代码来体会一下")]),t._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("num")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo: "')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" num "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 记录 foo 被调用的次数")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \nfoo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" i \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// foo: 6")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// foo: 7")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// foo: 8")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// foo: 9")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// foo 被调用了多少次？")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 0 --wtf? ")]),t._v("\n")])])]),a("p",[t._v("从代码执行结果来看很明显就可以得出此时 this 并不是指向自身。执行 foo.count = 0 的时候，的确向函数对象 foo 添加了一个属性 count 。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同。")]),t._v(" "),a("h3",{attrs:{id:"误解二-：-this-指向函数的作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#误解二-：-this-指向函数的作用域"}},[t._v("#")]),t._v(" 误解二 ： this 指向函数的作用域")]),t._v(" "),a("p",[t._v("第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下是错误的。")]),t._v(" "),a("p",[t._v("需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 Javascript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部")]),t._v(" "),a("p",[t._v("思考以下代码")]),t._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("     \n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     \n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a is not defined")]),t._v("\n")])])]),a("p",[t._v("这段代码试图通过"),a("strong",[t._v("this.bar")]),t._v(" 来引用 "),a("strong",[t._v("bar( )")]),t._v(" 函数。这是绝对不可能成功的，调用 "),a("strong",[t._v("bar()")]),t._v(" 最自然的方法是省略掉前面的 "),a("strong",[t._v("this")]),t._v(" ，直接使用词法引用标识符。")]),t._v(" "),a("p",[t._v("此外，编写这段代码的开发者还试图使用 this 联通 foo 和 bar 的词法作用域，从而让 bar 可以访问 foo 作用域里的变量  。这是不可能实现的，你不能使用 this 来引用一个词法作用域内部的东西。")]),t._v(" "),a("h2",{attrs:{id:"this是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this是什么"}},[t._v("#")]),t._v(" This是什么")]),t._v(" "),a("p",[t._v("this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置并没有任何关系，只取决于函数的调用方式。")]),t._v(" "),a("p",[t._v("当一个函数被调用时，会创建一个活动记录（执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。")]),t._v(" "),a("h3",{attrs:{id:"判断规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断规则"}},[t._v("#")]),t._v(" 判断规则")]),t._v(" "),a("p",[t._v("如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("由new 调用？绑定到新创建的对象")])]),t._v(" "),a("li",[a("p",[t._v("由call 或者 apply （或者bind）调用？ 绑定到指定的对象")])]),t._v(" "),a("li",[a("p",[t._v("由上下文对象调用？ 绑定到那个上下文对象")])]),t._v(" "),a("li",[a("p",[t._v("默认：在严格模式下绑定到 undefined，否则绑定到全局对象")])])]),t._v(" "),a("p",[t._v("一定要注意，有些调用可能在无意中使用默认绑定规则。如果想‘更安全’地忽略 this 绑定，可以使用一个 DMZ 对象，以保护全局对象")]),t._v(" "),a("p",[t._v("ES6 中的箭头函数并不适用于四条标准规则，而是根据当前的词法作用域来决定 this，具体来说就是继承外层函数调用的 this绑定。这和 self = this 机制一样，并且箭头函数的this 绑定后无法更改。")]),t._v(" "),a("p",[t._v("如果你经常编写 this 风格的代码，但是绝大部分使用 self = this或者箭头函数来否定this 机制，那么你或许应当：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("只使用词法作用域并且完全抛弃错误 this 风格")])]),t._v(" "),a("li",[a("p",[t._v("完全采用this 风格，在必要时使用 bind（硬绑定）")])])]),t._v(" "),a("h2",{attrs:{id:"简单理解原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单理解原理"}},[t._v("#")]),t._v(" 简单理解原理")]),t._v(" "),a("p",[t._v("我们平时创建的对象例如 var bar = { a : 2 }，浏览器是会先在内存中开辟一个空间，里面存放的是 a : 2，然后再把这个空间的地址赋给 bar，那么假如我们的对象中有函数，{ a : 2, foo : function(){} }，此时浏览器同样也会在内存中为函数 foo 开辟一个新的内存地址，那么由于函数是一个单独的值，所以它在不同的环境（上下文）执行。")]),t._v(" "),a("h2",{attrs:{id:"对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[t._v("#")]),t._v(" 对象")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("JavaScipt 中的对象有字面形式（比如 var a = { ... }）和构造形式（ var a  = new Array( ... )）。字面形式更常用，不过有时候构造形式可以提供更多选项。")])]),t._v(" "),a("li",[a("p",[t._v("‘JavaScript中万物皆对象’这是错误的。对象是六个基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [ object Array ] 表示这是对象的子类型数组。")])]),t._v(" "),a("li",[a("p",[t._v("对象就是键/值对的集合。可以通过 .propName 或者 [ 'propName' ]语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [ Get ] 操作（在设置属性值时时[ Put ]），[ Get ] 操作会检查对象本身是否包含这个属性，如果没找到的话还会沿着 prototype 查找")])]),t._v(" "),a("li",[a("p",[t._v("属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions( ... )、 Object.seal( ... )和 Object.freeze( ... )来设置对象的不可变性级别")])]),t._v(" "),a("li",[a("p",[t._v("属性不一定包含值——它们可能是具备了 getter/setter 的‘访问描述符’。此外，属性是可枚举或者不可枚举的，这决定了它们是否出现在 for ... in 循环中")])])]),t._v(" "),a("h2",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[t._v("#")]),t._v(" 类")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript也有类似的语法，但是和其他语言中的类完全不同。")])]),t._v(" "),a("li",[a("p",[t._v("类意味着复制。传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被赋值到子类中。")])]),t._v(" "),a("li",[a("p",[t._v("多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。")])]),t._v(" "),a("li",[a("p",[t._v("JavaScript并不会自动创建对象的副本。混入模式（Mixin）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显示伪多态（ otherObj.methodName.call( this, ... ) ），这会让代码更难懂并且难以维护。")])]),t._v(" "),a("li",[a("p",[t._v("总的来说，在JavaScript中模拟类是得不偿失的，虽然能解决当前问题，但是可能会留下更多的隐患。")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);