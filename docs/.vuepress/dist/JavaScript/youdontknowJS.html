<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>对《你不知道的JS》的记录 二 | Haha的个人Blog</title>
    <meta name="description" content="如果你工作很忙，除了你是真的很重要之外，更可能的原因是：你很弱。">
    <link rel="icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/0.styles.4c3b1344.css" as="style"><link rel="preload" href="/assets/js/app.510fc359.js" as="script"><link rel="preload" href="/assets/js/2.7d99f056.js" as="script"><link rel="preload" href="/assets/js/17.4f4f3a63.js" as="script"><link rel="prefetch" href="/assets/js/10.896e73a8.js"><link rel="prefetch" href="/assets/js/11.129c8d6c.js"><link rel="prefetch" href="/assets/js/12.7c8c4e6d.js"><link rel="prefetch" href="/assets/js/13.f74be3f6.js"><link rel="prefetch" href="/assets/js/14.e467f221.js"><link rel="prefetch" href="/assets/js/15.5e06996a.js"><link rel="prefetch" href="/assets/js/16.5c9e7dfd.js"><link rel="prefetch" href="/assets/js/18.2efdb6f8.js"><link rel="prefetch" href="/assets/js/19.6ecdc342.js"><link rel="prefetch" href="/assets/js/20.3e3efa73.js"><link rel="prefetch" href="/assets/js/21.59ed5385.js"><link rel="prefetch" href="/assets/js/22.af610e03.js"><link rel="prefetch" href="/assets/js/23.7c6728ee.js"><link rel="prefetch" href="/assets/js/24.135582e7.js"><link rel="prefetch" href="/assets/js/25.36939866.js"><link rel="prefetch" href="/assets/js/26.b155e29f.js"><link rel="prefetch" href="/assets/js/3.0bd0194e.js"><link rel="prefetch" href="/assets/js/4.7177fe92.js"><link rel="prefetch" href="/assets/js/5.68ee920c.js"><link rel="prefetch" href="/assets/js/6.c2d7d4e2.js"><link rel="prefetch" href="/assets/js/7.acf77970.js"><link rel="prefetch" href="/assets/js/8.7ee0b667.js"><link rel="prefetch" href="/assets/js/9.186c862b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4c3b1344.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Haha的个人Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人文章" class="dropdown-title"><span class="title">个人文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/HTTP/" class="nav-link">HTTP</a></li><li class="dropdown-item"><!----> <a href="/Library/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/Wheel/" class="nav-link">小程序</a></li></ul></div></div><div class="nav-item"><a href="/Project/" class="nav-link">最近阅读的书籍</a></div><div class="nav-item"><a href="/Resume/" class="nav-link">个人简介</a></div><div class="nav-item"><a href="https://github.com/hubingliang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  BitBuket
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人文章" class="dropdown-title"><span class="title">个人文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/HTTP/" class="nav-link">HTTP</a></li><li class="dropdown-item"><!----> <a href="/Library/" class="nav-link">node</a></li><li class="dropdown-item"><!----> <a href="/Wheel/" class="nav-link">小程序</a></li></ul></div></div><div class="nav-item"><a href="/Project/" class="nav-link">最近阅读的书籍</a></div><div class="nav-item"><a href="/Resume/" class="nav-link">个人简介</a></div><div class="nav-item"><a href="https://github.com/hubingliang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  BitBuket
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/JavaScript/" class="sidebar-link">对《你不知道的JS》的记录 一</a></li><li><a href="/JavaScript/youdontknowJS.html" class="active sidebar-link">对《你不知道的JS》的记录 二</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/youdontknowJS.html#关于this的两个误解" class="sidebar-link">关于This的两个误解</a></li><li class="sidebar-sub-header"><a href="/JavaScript/youdontknowJS.html#this是什么" class="sidebar-link">This是什么</a></li><li class="sidebar-sub-header"><a href="/JavaScript/youdontknowJS.html#简单理解原理" class="sidebar-link">简单理解原理</a></li><li class="sidebar-sub-header"><a href="/JavaScript/youdontknowJS.html#对象" class="sidebar-link">对象</a></li><li class="sidebar-sub-header"><a href="/JavaScript/youdontknowJS.html#类" class="sidebar-link">类</a></li></ul></li><li><a href="/JavaScript/event.html" class="sidebar-link">事件以及事件对象</a></li><li><a href="/JavaScript/eventLoop.html" class="sidebar-link">异步相关以及 Event Loop</a></li><li><a href="/JavaScript/prototype.html" class="sidebar-link">原型</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="对《你不知道的js》的记录-二"><a href="#对《你不知道的js》的记录-二" class="header-anchor">#</a> 对《你不知道的JS》的记录 二</h1> <p>this关键字是 JavaScript 中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。接下来会先讲一下This，然后再涉及对象和类的相关知识。</p> <h2 id="关于this的两个误解"><a href="#关于this的两个误解" class="header-anchor">#</a> 关于This的两个误解</h2> <h3 id="误解一-：-this-指向自身"><a href="#误解一-：-this-指向自身" class="header-anchor">#</a> 误解一 ： this 指向自身</h3> <p>人们很容易把 this 理解成指向引用函数自身，这个推断从英语角度来讲是说得通的。</p> <p>为什么要在函数内部调用自身呢？常见的原因的递归（自己调用自己）</p> <p>我们可以通过以下代码来体会一下</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span> <span class="token parameter">num</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;foo: &quot;</span> <span class="token operator">+</span> num <span class="token punctuation">)</span>
  <span class="token comment">// 记录 foo 被调用的次数</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">++</span>
<span class="token punctuation">}</span> 
foo<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> i 
<span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// foo: 6</span>
<span class="token comment">// foo: 7</span>
<span class="token comment">// foo: 8</span>
<span class="token comment">// foo: 9</span>
<span class="token comment">// foo 被调用了多少次？</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> foo<span class="token punctuation">.</span>count <span class="token punctuation">)</span>  <span class="token comment">// 0 --wtf? </span>
</code></pre></div><p>从代码执行结果来看很明显就可以得出此时 this 并不是指向自身。执行 foo.count = 0 的时候，的确向函数对象 foo 添加了一个属性 count 。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同。</p> <h3 id="误解二-：-this-指向函数的作用域"><a href="#误解二-：-this-指向函数的作用域" class="header-anchor">#</a> 误解二 ： this 指向函数的作用域</h3> <p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下是错误的。</p> <p>需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 Javascript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部</p> <p>思考以下代码</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>     
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>     
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token comment">// a is not defined</span>
</code></pre></div><p>这段代码试图通过<strong>this.bar</strong> 来引用 <strong>bar( )</strong> 函数。这是绝对不可能成功的，调用 <strong>bar()</strong> 最自然的方法是省略掉前面的 <strong>this</strong> ，直接使用词法引用标识符。</p> <p>此外，编写这段代码的开发者还试图使用 this 联通 foo 和 bar 的词法作用域，从而让 bar 可以访问 foo 作用域里的变量  。这是不可能实现的，你不能使用 this 来引用一个词法作用域内部的东西。</p> <h2 id="this是什么"><a href="#this是什么" class="header-anchor">#</a> This是什么</h2> <p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置并没有任何关系，只取决于函数的调用方式。</p> <p>当一个函数被调用时，会创建一个活动记录（执行上下文）。这个记录会包含函数在哪里被调用、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p> <h3 id="判断规则"><a href="#判断规则" class="header-anchor">#</a> 判断规则</h3> <p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象</p> <ol><li><p>由new 调用？绑定到新创建的对象</p></li> <li><p>由call 或者 apply （或者bind）调用？ 绑定到指定的对象</p></li> <li><p>由上下文对象调用？ 绑定到那个上下文对象</p></li> <li><p>默认：在严格模式下绑定到 undefined，否则绑定到全局对象</p></li></ol> <p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想‘更安全’地忽略 this 绑定，可以使用一个 DMZ 对象，以保护全局对象</p> <p>ES6 中的箭头函数并不适用于四条标准规则，而是根据当前的词法作用域来决定 this，具体来说就是继承外层函数调用的 this绑定。这和 self = this 机制一样，并且箭头函数的this 绑定后无法更改。</p> <p>如果你经常编写 this 风格的代码，但是绝大部分使用 self = this或者箭头函数来否定this 机制，那么你或许应当：</p> <ol><li><p>只使用词法作用域并且完全抛弃错误 this 风格</p></li> <li><p>完全采用this 风格，在必要时使用 bind（硬绑定）</p></li></ol> <h2 id="简单理解原理"><a href="#简单理解原理" class="header-anchor">#</a> 简单理解原理</h2> <p>我们平时创建的对象例如 var bar = { a : 2 }，浏览器是会先在内存中开辟一个空间，里面存放的是 a : 2，然后再把这个空间的地址赋给 bar，那么假如我们的对象中有函数，{ a : 2, foo : function(){} }，此时浏览器同样也会在内存中为函数 foo 开辟一个新的内存地址，那么由于函数是一个单独的值，所以它在不同的环境（上下文）执行。</p> <h2 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h2> <ol><li><p>JavaScipt 中的对象有字面形式（比如 var a = { ... }）和构造形式（ var a  = new Array( ... )）。字面形式更常用，不过有时候构造形式可以提供更多选项。</p></li> <li><p>‘JavaScript中万物皆对象’这是错误的。对象是六个基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [ object Array ] 表示这是对象的子类型数组。</p></li> <li><p>对象就是键/值对的集合。可以通过 .propName 或者 [ 'propName' ]语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [ Get ] 操作（在设置属性值时时[ Put ]），[ Get ] 操作会检查对象本身是否包含这个属性，如果没找到的话还会沿着 prototype 查找</p></li> <li><p>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions( ... )、 Object.seal( ... )和 Object.freeze( ... )来设置对象的不可变性级别</p></li> <li><p>属性不一定包含值——它们可能是具备了 getter/setter 的‘访问描述符’。此外，属性是可枚举或者不可枚举的，这决定了它们是否出现在 for ... in 循环中</p></li></ol> <h2 id="类"><a href="#类" class="header-anchor">#</a> 类</h2> <ol><li><p>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript也有类似的语法，但是和其他语言中的类完全不同。</p></li> <li><p>类意味着复制。传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被赋值到子类中。</p></li> <li><p>多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。</p></li> <li><p>JavaScript并不会自动创建对象的副本。混入模式（Mixin）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显示伪多态（ otherObj.methodName.call( this, ... ) ），这会让代码更难懂并且难以维护。</p></li> <li><p>总的来说，在JavaScript中模拟类是得不偿失的，虽然能解决当前问题，但是可能会留下更多的隐患。</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JavaScript/" class="prev router-link-active">对《你不知道的JS》的记录 一</a></span> <span class="next"><a href="/JavaScript/event.html">事件以及事件对象</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.510fc359.js" defer></script><script src="/assets/js/2.7d99f056.js" defer></script><script src="/assets/js/17.4f4f3a63.js" defer></script>
  </body>
</html>
