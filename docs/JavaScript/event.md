# 事件以及事件对象

## 什么是事件
事件就是一件事情或者一个行为（对于元素来说，它的很多事件都是天生自带的），只要我们去操作这个元素，就会触发这些行为。

**事件就是元素天生自带的行为，我们操作元素，就会触发相关的行为**

## 事件绑定的操作方式
* 目的   
给当前元素的某个事件绑定方法（不管是DOM0还是DOM2），都是为了触发元素的相关行为，能做点事情（也就是把绑定的方法执行）；“不仅把方法执行了，而且浏览器还给方法传递了一个实参信息值===>这个值就是事件对象”

* DOM 0级事件绑定   
```js
element.onXXX = function(){}
```

* DOM 2级事件绑定
```js
element.addEvenListener('xxx' , function( ) { },false);
element.attachEvent('onXXX',function( ) { }); IE 6-8
```

* 例子
```js
box.onclick = functinon ( ev ) {}
```
1. 定义一个形参EV用来接收方法执行的时候，浏览器传递的信息值（事件对象：MouseEvent鼠标事件对象、KeyboardEvent键盘事件对象、Event普通事件对象...）

2. 事件对象中记录了很多属性名和属性值，这些信息中包含了当前操作的基础信息，例如：鼠标点击位置的x/Y轴坐标，鼠标点击的是谁（事件源）等信息

## 事件对象的兼容问题
* IE6-8   
在IE低版本浏览器中，浏览器执行绑定的方法，并没有把事件对象传递进来，此时ev === undefined，需要基于window.event 来获取（由于是全局属性，鼠标每次操作都会把上一次操作的值替换掉）

* 解决方案-先手动设置   
低版本没有的属性，我们手动设置一下：按照自己有的先获取到值，然后赋值给标准对应的新属性。

## 事件的默认行为
事件本身就是天生就有的，某些事件触发，即使你没有绑定方法，也会存在一些效果，这些默认的效果就是“事件的默认行为”

**例如**

1. A标签的点击操作就存在默认行为
    1. 页面跳转

    2. 锚点定位( HASH 定位)

2. input标签也有自己的默认行为
    1. 输入内容可以呈现到文本框中

    2. 输入内容的时候会把之前输入的一些信息呈现出来（并不是所有浏览器和所有情况都有）

3. submit按钮   
    1. 点击按钮页面会刷新

**如何阻止默认行为**

1. 直接return false

2. ev.preventDefault ? ev.preventDefault( ) : ev.returnValue = false;

## 事件的传播机制

* 捕获阶段-capturing_phase   

点击INNER的时候，首先会从最外层开始向内查找（找到操作的事件源），查找的目的是，构建出冒泡传播阶段需要传播的路线（查找就是按照HTML层级结构找的）

* 目标阶段-at_target   

把事件源的相关操作行为触发（如果绑定了方法，则把方法执行）

* 冒泡阶段-bubbling_phase   

按照捕获阶段规划的路线，自内而外，把当前事件源的祖先元素的相关事件行为依次触发（如果某一个祖先元素事件行为绑定了方法，则把方法执行，没绑定方法，行为触发了，什么都不做，继续向上传播即可）

## 事件委托(事件代理)

利用事件的**冒泡传播机制**，如果一个容器的后代元素中，很多元素的点击行为（其他事件行为也是）都要做一些处理，此时我们不需要在像以前一样一个一个获取一个个绑定，我们只需给容器的click绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而做不同的事情即可。

## 对比DOM0 和 DOM2的事件绑定

* DOM0 事件绑定   

只允许给当前元素的某个事件行为绑定一个方法，多次绑定，后面绑定的内容会替换前面绑定的，以最后一次绑定的为主。原理：就是给元素的某一个事件私有属性赋值（浏览器会建立监听机制，当我们触发元素的某个行为，浏览器会自己把属性中赋的值去执行）

* DOM2 事件绑定   

1. 基于addEventListener 完成事件绑定，是基于“事件池机制”完成的。

2. DOM2 可以给当前元素的某一个事件绑定多个不同的方法。既可以给这个事件绑定多个点击的方法：
```js
    element.addEventListener('click', fn1, false)
    element.addEventListener('click', fn2, false)
    element.addEventListener('click', fn3, false)
    element.addEventListener('click', fn1, false) //注意如果事件池中以及存在则不会添加
```
当我们触发element的点击行为后，浏览器会按照事件池中其存放增加的顺序依次把监听的方法给触发（浏览器只有一个事件池）