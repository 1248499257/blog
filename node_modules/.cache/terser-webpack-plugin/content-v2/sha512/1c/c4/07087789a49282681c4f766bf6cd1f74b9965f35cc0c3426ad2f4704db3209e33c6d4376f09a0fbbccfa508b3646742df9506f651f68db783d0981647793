{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{207:function(t,v,_){\"use strict\";_.r(v);var s=_(0),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[_(\"h1\",{attrs:{id:\"关于网络协议-http-和-tls\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#关于网络协议-http-和-tls\"}},[t._v(\"#\")]),t._v(\" 关于网络协议 HTTP 和 TLS\")]),t._v(\" \"),_(\"h2\",{attrs:{id:\"http基本概念\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http基本概念\"}},[t._v(\"#\")]),t._v(\" HTTP基本概念\")]),t._v(\" \"),_(\"p\",[t._v(\"HTTP的全称是 \"),_(\"strong\",[t._v(\"超文本传输协议\")]),t._v(\"，也是现今在 \"),_(\"strong\",[t._v(\"WWW\")]),t._v(\" 上应用最多的协议，\"),_(\"strong\",[t._v(\"HTTP\")]),t._v(\"是应用层协议，当你上网浏览网页的时候，浏览器和web服务器就会通过\"),_(\"strong\",[t._v(\"HTTP\")]),t._v(\" 在 \"),_(\"strong\",[t._v(\"Internet\")]),t._v(\" 上进行数据的发送和接受。HTTP是一个基于\"),_(\"strong\",[t._v(\"请求/相应模式的、无状态的协议\")]),t._v(\"。\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"特点\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#特点\"}},[t._v(\"#\")]),t._v(\" 特点\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[t._v(\"无连接：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"无状态： HTTP协议是无状态协议。无状态是指协议对于事物处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样会导致每次连接传送的数据量增大。另一方面，在无服务不需要先前信息时它的应答就比较快。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"灵活：HTTP允许传输任意类型的数据对象。正在传输的类型有 Content-Type加以标记。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"简单快速：客户端向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模比较小，因而通信速度很快。\")])])]),t._v(\" \"),_(\"h3\",{attrs:{id:\"http的请求三部分\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http的请求三部分\"}},[t._v(\"#\")]),t._v(\" HTTP的请求三部分\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[t._v(\"请求行\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"首部\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"实体\")])])]),t._v(\" \"),_(\"p\",[t._v(\"请求行大概长这样\")]),t._v(\" \"),_(\"div\",{staticClass:\"language-js extra-class\"},[_(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[_(\"code\",[_(\"span\",{pre:!0,attrs:{class:\"token constant\"}},[t._v(\"GET\")]),_(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"images\"),_(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),t._v(\"logo\"),_(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"gif \"),_(\"span\",{pre:!0,attrs:{class:\"token constant\"}},[t._v(\"HTTP\")]),_(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"/\")]),_(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1.1\")]),t._v(\"  \\n\")])])]),_(\"p\",[t._v(\"基本由 \"),_(\"strong\",[t._v(\"请求方法、URL、协议版本\")]),t._v(\"组成，其中值得一提的就是请求方法了。\")]),t._v(\" \"),_(\"h4\",{attrs:{id:\"请求方法有很八种：\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#请求方法有很八种：\"}},[t._v(\"#\")]),t._v(\" 请求方法有很八种：\")]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"GET 、POST 、 PUT 、 DELETE 、 OPTIONS 、 HEAD、 TRACE、 CONNECT\")]),_(\"br\"),t._v(\"\\n但是最常用的也就是GET 和 POST了。虽然请求方法有很多，但是更多的方法只是传递一个\"),_(\"strong\",[t._v(\"语义\")]),t._v(\"，只是为了语义化提交方式，而不是说POST能做的事情，GET就不能做了。如果你喜欢，都是用GET请求或者POST请求也是可以的。\")]),t._v(\" \"),_(\"h4\",{attrs:{id:\"从技术层面讲一下get-和-post两者的区别：\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#从技术层面讲一下get-和-post两者的区别：\"}},[t._v(\"#\")]),t._v(\" 从技术层面讲一下GET 和 POST两者的区别：\")]),t._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[t._v(\"Get能缓存，POST不能\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"POST相对GET会安全一点点，因为Get请求都包含在URL里面（当然你写在body里面也是可以的），且会被浏览器保存历史纪录。Post不会，但是在抓包的情况下两者都是一样的。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"URL有长度限制，会影响Get请求，但是这个长度限制是浏览器规定的，不是RFC规定的。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"Post支持更多的编码类型且不对数据类型限制。\")])])]),t._v(\" \"),_(\"h4\",{attrs:{id:\"首部\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#首部\"}},[t._v(\"#\")]),t._v(\" 首部\")]),t._v(\" \"),_(\"p\",[t._v(\"分为请求首部和响应首部，并且部分首部两种通用，接下来我们就来学习一部分的常用首部。\")]),t._v(\" \"),_(\"p\",[t._v(\"通用首部\\n\"),_(\"img\",{attrs:{src:\"images/HTTP_1.png\",alt:\"\"}}),_(\"br\"),t._v(\"\\n请求首部\"),_(\"br\"),t._v(\"\\n响应首部\"),_(\"br\"),t._v(\"\\n实体首部\")]),t._v(\" \"),_(\"h4\",{attrs:{id:\"常见状态码\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常见状态码\"}},[t._v(\"#\")]),t._v(\" 常见状态码\")]),t._v(\" \"),_(\"p\",[t._v(\"状态码表示了响应的一个状态，可以让我们清晰的了解到这一次请求还是成功还是失败，假如是失败，也可以知道是什么原因导致的，当然状态码也是用于传达语义的。如果胡乱使用，那么它存在的意义就没有了。\")]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"2XX 成功\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"200 OK，表示从客户端发来的请求在服务器端被正确处理\")]),t._v(\" \"),_(\"li\",[t._v(\"204 No content，表示请求成功，但响应报文不含实体的主体部分\")]),t._v(\" \"),_(\"li\",[t._v(\"205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容\")]),t._v(\" \"),_(\"li\",[t._v(\"206 Partial Content，进行范围请求\")])]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"3XX 重定向\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\")]),t._v(\" \"),_(\"li\",[t._v(\"302 found，临时性重定向，表示资源临时被分配了新的 URL\")]),t._v(\" \"),_(\"li\",[t._v(\"303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源\")]),t._v(\" \"),_(\"li\",[t._v(\"304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\")]),t._v(\" \"),_(\"li\",[t._v(\"307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求\")])]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"4XX 客户端错误\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"400 bad request，请求报文存在语法错误\")]),t._v(\" \"),_(\"li\",[t._v(\"401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\")]),t._v(\" \"),_(\"li\",[t._v(\"403 forbidden，表示对请求资源的访问被服务器拒绝\")]),t._v(\" \"),_(\"li\",[t._v(\"404 not found，表示在服务器上没有找到请求的资源\")])]),t._v(\" \"),_(\"p\",[_(\"strong\",[t._v(\"5XX 服务器错误\")])]),t._v(\" \"),_(\"ul\",[_(\"li\",[t._v(\"500 internal sever error，表示服务器端在执行请求时发生了错误\")]),t._v(\" \"),_(\"li\",[t._v(\"501 Not Implemented，表示服务器不支持当前请求所需要的某个功能\")]),t._v(\" \"),_(\"li\",[t._v(\"503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\")])]),t._v(\" \"),_(\"h2\",{attrs:{id:\"tls\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tls\"}},[t._v(\"#\")]),t._v(\" TLS\")]),t._v(\" \"),_(\"p\",[t._v(\"HTTPS 还是通过 \"),_(\"strong\",[t._v(\"HTTP\")]),t._v(\" 来传输信息，但是信息通过了 \"),_(\"strong\",[t._v(\"TLS\")]),t._v(\" 协议进行了加密。\")]),t._v(\" \"),_(\"p\",[t._v(\"TLS 协议位于传输层之上，应用层之下。首个进行 TLS协议 传输需要两个RTT，接下来可以通过 Session Resumption 减少到一个RTT。\")]),t._v(\" \"),_(\"p\",[t._v(\"在TLS 中使用了两种加密技术，分别为 \"),_(\"strong\",[t._v(\"对称加密\")]),t._v(\"和 \"),_(\"strong\",[t._v(\"非对称加密\")]),t._v(\"。\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"对称加密：\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对称加密：\"}},[t._v(\"#\")]),t._v(\" 对称加密：\")]),t._v(\" \"),_(\"p\",[t._v(\"对称加密就是两边拥有相同的密钥，两边都知道如何将密文加密解密。\")]),t._v(\" \"),_(\"p\",[t._v(\"这种加密方式固然很好，但是问题在于如何让双方知道密钥。因为传输数据都是走的网络，如果将密钥通过网络的方式传递的话，一旦密钥被捕获就没有加密的意义了。\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"非对称加密：\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#非对称加密：\"}},[t._v(\"#\")]),t._v(\" 非对称加密：\")]),t._v(\" \"),_(\"p\",[t._v(\"有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥，私钥只有分发公钥的一方才知道。\")]),t._v(\" \"),_(\"p\",[t._v(\"这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在此之前，可以先使用非对称加密交换密钥。\")]),t._v(\" \"),_(\"h3\",{attrs:{id:\"简单流程如下：\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#简单流程如下：\"}},[t._v(\"#\")]),t._v(\" 简单流程如下：\")]),t._v(\" \"),_(\"p\",[t._v(\"首先服务端将公钥公布出去了，那么客户端也知道了公钥。接下来客户端创建一个密钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的密钥，这时候两端就都知道密钥是什么了。\")]),t._v(\" \"),_(\"p\",[t._v(\"TLS 握手过程如下图：\")]),t._v(\" \"),_(\"ol\",[_(\"li\",[_(\"p\",[t._v(\"客户端发送一个随机值以及需要的协议和加密方式。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密。\")])]),t._v(\" \"),_(\"li\",[_(\"p\",[t._v(\"通过以上步骤可知，在TLS握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。\")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}